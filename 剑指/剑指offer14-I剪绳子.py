# 题目：
"""
现需要将一根长为正整数 bamboo_len 的竹子砍为若干段，每段长度均为正整数。请返回每段竹子长度的最大乘积是多少。

示例 1：

输入: bamboo_len = 12
输出: 81
"""
# 重要证明公式：算数几何均值不等式：设a1,a2,...,an是n个正数，则有(a1+a2+...+an)/n >= (a1*a2*...*an)^(1/n)，可以通过数学归纳法证明
    #证明n=2时成立，假设n=k时成立，即(a1+a2+...+ak)/k >= (a1*a2*...*ak)^(1/k)
    #则当n=k+1时，拆分k+1为分母的等式即可证明
    # 公式在a1=a2=...=an时取等号，即所有数相等时等号成立
    
# 之后得到 n = ax, x是每段的长度，a是段数，将问题转化为求解x^a=x^(1/x)^n的最大值，等同于求解x^(1/x)的最大值
    # x^(1/x)两边同时求lon，通过求解导数为0的点，和分析单调性，得到x=e，即e为x^(1/x)的最大值
    # x只能为整数，所以代入x=2和3进行对比，
    # x=2时，2^1/2=1.41，x=3时，3^1/3=1.44，所以x=3时最大 
"""
得到x=3时最大

改题目改写为，将n分为a段，每段长度为3，求解3^a的最大值
"""

class Solution:
    def cuttingBamboo(self, bamboo_len: int) -> int:
        # 如果竹子长度小于等于3，直接返回竹子长度-1（因为至少要分为两段，3为2*1,2为1*1）
        if bamboo_len <= 3:
            return bamboo_len - 1
        # 一般情况
        # 能分成多少个3
        a = bamboo_len // 3
        # 余数
        b = bamboo_len % 3
        if b == 0:
            return 3 ** a
        # 因为*1 不改变大小
        if b == 1:
            return 3 ** (a - 1) * 4
        # 如果余数为2，那么就是3^a*2
        return 3 ** a * b

    
